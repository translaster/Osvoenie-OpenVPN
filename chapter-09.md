# Глава 9. Устранение неполадок и настройка

Обычно довольно легко настроить VPN с использованием OpenVPN. Это одна из самых привлекательных функций OpenVPN по сравнению с другими решениями VPN. Однако иногда необходимо устранить неполадки в нерабочей настройке или настроить существующую настройку для повышения производительности.

Устранение неполадок и настройка OpenVPN часто игнорируются. Файлы журнала OpenVPN на стороне клиента и сервера предоставляют много информации, но вы должны знать как их читать. При настройке файлов конфигурации клиента и сервера также допускается довольно много ошибок. В этой главе вы узнаете, как интерпретировать файлы журнала OpenVPN и как обнаруживать и исправлять некоторые из этих распространенных ошибок.

Наконец, существует большая разница между рабочей установкой и установкой, которая работает хорошо. Возможно, ваша установка OpenVPN работает правильно, но пользователи все равно могут жаловаться на низкую производительность. Получение максимальной производительности от установки OpenVPN может показаться черной магией. В этой главе вы узнаете немного этой черной магии.

В этой главе будут рассмотрены следующие темы:

* Как читать файлы журнала
* Исправление распространенных ошибок конфигурации
* Устранение проблем с маршрутизацией
* Как оптимизировать производительность с помощью `ping` и `iperf`
* Анализ трафика OpenVPN с использованием `tcpdump`

## Как читать файлы журнала

Поначалу отладка нерабочих настроек может показаться сложной задачей. С чего начать? К счастью, OpenVPN предоставляет отличные средства ведения журналов и отладки. Однако с увеличением степени детализации журналов становится все труднее читать эти файлы журналов. Уровень детализации журнала OpenVPN по умолчанию равен `1`, но рекомендуется установить степень детализации `3`. Это часто дает администратору достаточно информации для обнаружения проблем с настройкой, в то же время сводя к минимуму потери производительности.

Установка детальности на `5` или выше рекомендуется только для целей отладки, так как это сильно повлияет на производительность.

Каждый пример в этой книге до сих пор включал устанку `verb 3`. Во-первых, мы рассмотрим файлы журнала клиента и сервера для рабочей настройки с такой детальностью. Важно понимать и, возможно, даже хранить файлы журналов работающего соединения. При попытке найти ошибку в нерабочей настройке, очень полезно сравнивать файлы журнала нерабочего случая с файлами рабочей настройки.

Запустите сервер, используя файл конфигурации по умолчанию `basic-udp-server.conf`:

```
[root@server]# openvpn --config basic-udp-server.conf
```

Пока не подключайтесь к клиенту. Файл журнала сервера теперь будет содержать следующее:

```
 1 14:53:27 OpenVPN 2.3.6 x86_64-redhat-linux-gnu
            [SSL (OpenSSL)] [LZO] [EPOLL] [PKCS11] [MH] [IPv6]
            built on Dec 2 2014
 2 14:53:27 library versions: OpenSSL 1.0.1e-fips 11 Feb 2013,
            LZO2.03
 3 14:53:27 Diffie-Hellman initialized with 2048 bit key
 4 14:53:31 WARNING: this configuration may cache passwords in
            memory -- use the auth-nocache option to prevent this
 5 14:53:31 Control Channel Authentication: using
            '/etc/openvpn/movpn/ta.key' as a OpenVPN static key
            file
 6 14:53:31 Outgoing Control Channel Authentication: Using 160
            bit message hash 'SHA1' for HMAC authentication
 7 14:53:31 Incoming Control Channel Authentication: Using 160
            bit message hash 'SHA1' for HMAC authentication
 8 14:53:31 Socket Buffers: R=[16777216->131072]
            S=[16777216->131072]
 9 14:53:31 TUN/TAP device tun0 opened
10 14:53:31 TUN/TAP TX queue length set to 100
11 14:53:31 do_ifconfig, tt->ipv6=0, tt-did_ifconfig_ipv6_setup=0
12 14:53:31 /sbin/ip link set dev tun0 up mtu 1500
13 14:53:31 /sbin/ip addr add dev tun0 10.200.0.1/24
broadcast 10.200.0.255
14 14:53:31 GID set to nobody
15 14:53:31 UID set to nobody
16 14:53:31 UDPv4 link local (bound): [undef]
17 14:53:31 UDPv4 link remote: [undef]
18 14:53:31 MULTI: multi_init called, r=256 v=256
19 14:53:31 IFCONFIG POOL: base=10.200.0.2 size=252, ipv6=0
20 14:53:31 Initialization Sequence Completed
```

Метки времени в начале каждой строки были сокращены для ясности.

Давайте посмотрим на этот файл журнала построчно:

* Строки 1 и 2 указывают версию и дату сборки самого OpenVPN, а также библиотеки, от которых зависит OpenVPN.
* Строка 3 говорит нам, что параметры Диффи-Хеллмана сервера были успешно инициализированы. Файл, указанный в строке конфигурации сервера `dh /etc/openvpn/movpn/dh2048.pem` был использован для этого.
* Строка 4 - это предупреждение, которое печатается почти всегда. Разработчики обсуждали, следует ли удалить эту строку или нет. В конце концов было решено, что по соображениям безопасности лучше всего распечатать это предупреждение. Если вы не слишком озабочены безопасностью, то можете игнорировать эту строку предупреждения.
* Строка 5 указывает, что канал управления защищен с использованием параметра конфигурации `tls-auth` и что OpenVPN смог успешно прочитать указанный файл.
* Строки 6 и 7 сообщают нам, что два ключа SHA1 получены из файла `tls-auth` и теперь используются для подписи (хэширования) исходящего трафика и для проверки входящего трафика.
* Строка 8 показывает размер буферов `Receive (R)` и `Send (S)`, которые использует OpenVPN. Эти параметры полезны только при доработке рабочей настройки, как мы увидим позже в этой главе.
* Строки 9 и 10 показывают что OpenVPN смог успешно открыть устройство tun и установить глубину очереди пакетов для этого устройства равной `100`.
* Строки с 11 по 13 показывают настройки IPv4, которые используются для этой конфигурации сервера. Они также указывают что не были заданы параметры IPv6. Перечисленные здесь настройки являются переводом строки конфигурации сервера `server 10.200.0.0 255.255.255.0`.
* Строки 14 и 15 являются результатом указания `group nobody` и `user nobody` в файле конфигурации сервера соответственно.
* Строки 16 и 17 показывают что OpenVPN прослушивает трафик UDP и привязан к неопределенному интерфейсу (0.0.0.0). Это результат указания `proto udp` и `bind` в файле конфигурации сервера.
* Строка 18 говорит нам, что это мультиклиентская установка с реальными и виртуальными размерами таблицы хешей `256`.
* В строке 19 указан диапазон адресов пула, доступных клиентам OpenVPN, которые могут подключаться к этому серверу. Это также часть перевода строки конфигурации сервера `server 10.200.0.0 255.255.255.0`.
* Строка 20 - это волшебная строка, которая сообщает нам, что сервер успешно запущен и инициализация завершена. Сервер теперь готов принимать соединения от входящих клиентов.

Далее мы запускаем клиент и смотрим файл журнала на стороне сервера:

```
[root@client]# openvpn --config basic-udp-client.conf
```

После этого мы также рассмотрим файл журнала на стороне клиента:

```
21 15:30:37 <CLIENT-IP>:39086 TLS: Initial packet from
            [AF_INET]<CLIENT-IP>:39086, sid=071ba589 7e9ff2a0
22 15:30:37 <CLIENT-IP>:39086 VERIFY OK: depth=1, C=ZA,
            ST=Enlightenment, L=Overall, O=Mastering OpenVPN,
            CN=Mastering OpenVPN, emailAddress=root@example.org
23 15:30:37 <CLIENT-IP>:39086 VERIFY OK: depth=0, C=ZA,
            ST=Enlightenment, O=Mastering OpenVPN, CN=client3,
            emailAddress=root@example.org
24 15:30:37 <CLIENT-IP>:39086 Data Channel Encrypt: Cipher
            'BF-CBC' initialized with 128 bit key
25 15:30:37 <CLIENT-IP>:39086 Data Channel Encrypt: Using 160 bit
            message hash 'SHA1' for HMAC authentication
26 15:30:37 <CLIENT-IP>:39086 Data Channel Decrypt: Cipher
            'BF-CBC' initialized with 128 bit key
27 15:30:37 <CLIENT-IP>:39086 Data Channel Decrypt: Using 160 bit
            message hash 'SHA1' for HMAC authentication
28 15:30:37 <CLIENT-IP>:39086 Control Channel: TLSv1, cipher
            TLSv1/SSLv3 DHE-RSA-AES256-SHA, 2048 bit RSA
29 15:30:37 <CLIENT-IP>:39086 [client3] Peer Connection Initiated
            with [AF_INET]<CLIENT-IP>:39086
30 15:30:37 client3/<CLIENT-IP>:39086 MULTI_sva: pool returned
            IPv4=10.200.0.2, IPv6=(Not enabled)
31 15:30:37 client3/<CLIENT-IP>:39086 MULTI: Learn: 10.200.0.2 →
            client3/<CLIENT-IP>:39086
32 15:30:37 client3/<CLIENT-IP>:39086 MULTI: primary virtual IP
            for client3/<CLIENT-IP>:39086: 10.200.0.2
33 15:30:39 client3/<CLIENT-IP>:39086 PUSH: Received control
            message: 'PUSH_REQUEST'
34 15:30:39 client3/<CLIENT-IP>:39086 send_push_reply():
            safe_cap=940
35 15:30:39 client3/<CLIENT-IP>:39086 SENT CONTROL [client3]:
            'PUSH_REPLY,route-gateway 10.200.0.1,topology subnet,
            ping 10,ping-restart 60,
            ifconfig 10.200.0.2 255.255.255.0' (status=1)
```

Давайте пройдемся по новым записям журнала:

* Строка 21 указывает, что исходный пакет был получен от клиента с IP-адресом `<CLIENT-IP>`. Обычно полный адрес IPv4 указан здесь.
* Строки 22 и 23 показывают процесс проверки сертификата, предоставленного клиентом OpenVPN. Важной частью в этих строках журнала является `VERIFY-OK`.
* Строки с 24 по 27 перечисляют используемый шифр шифрования и дешифрования, а также хэши `SHA1`, используемые для хеширования входящего и исходящего трафика в канале данных. **BF-CBC (Blowfish Cipher Block Chaining)** - текущий шифр по умолчанию для OpenVPN.
* В строке 28 показан шифр TLS, используемый для защиты канала управления OpenVPN. Перечисленный здесь шифр очень похож на код шифрования, используемый защищенным веб-сервером.
* Строка 29 указывает, что клиент `client3` с IP-адреса` <CLIENT-IP>` успешно прошел процесс аутентификации.
* В строках с 30 по 32 указывается адрес пула, который будет назначен этому клиенту.
* Строки с 33 по 34 показывают что клиент запросил информацию о конфигурации (`PUSH REQUEST`) и ответ от сервера - он отправляет `push_reply`.
* Строка 35 показывает содержимое сообщения `push_reply` со всей информацией о конфигурации для этого клиента. Эта строка чрезвычайно полезна при отладке установки OpenVPN, поскольку она показывает большую часть информации, которую сервер OpenVPN имеет для конкретного клиента, независимо от используемого файла конфигурации.

Аналогично, вот файл журнала клиента (запишите временные метки и сопоставьте их с временными метками из файла журнала сервера):

```
 1 15:30:37 OpenVPN 2.3.6 x86_64-redhat-linux-gnu
            [SSL (OpenSSL)] [LZO] [EPOLL] [PKCS11] [MH] [IPv6]
            built on Dec 2 2014
 2 15:30:37 library versions: OpenSSL 1.0.1e-fips 11 Feb 2013,
            LZO 2.03
 3 15:30:37 Control Channel Authentication: using
            '/etc/openvpn/movpn/ta.key' as a OpenVPN static key
            file
 4 15:30:37 UDPv4 link local: [undef]
 5 15:30:37 UDPv4 link remote: [AF_INET]<SERVER-IP>:1194
 6 15:30:37 [Mastering OpenVPN Server] Peer Connection Initiated
            with [AF_INET]<SERVER-IP>:1194
 7 15:30:39 TUN/TAP device tun0 opened
 8 15:30:39 do_ifconfig, tt->ipv6=0, tt-did_ifconfig_ipv6_setup=0
 9 15:30:39 /sbin/ip link set dev tun0 up mtu 1500
10 15:30:39 /sbi/nip addr add dev tun0 10.200.0.2/24
            broadcast 10.200.0.255
11 15:30:39 Initialization Sequence Completed
```

Давайте пройдемся по новым записям журнала:

* Строки 1 и 2 очень похожи на строки из журнала сервера.
* Строка 3 указывает, что канал управления защищен с помощью параметра конфигурации `tls-auth` и OpenVPN смог успешно прочитать указанный файл.
* Строки 4 и 5 говорят нам что клиент не связывался с локальным IP-адресом и было установлено соединение UDP с сервером по IP-адресу `<SERVER-IP>` и порту `1194`.
* В строке 6 указано, что соединение с сервером OpenVPN, идентифицирующим себя как `Mastering OpenVPN Server`, было успешно установлено. Имя сервера извлекается из **общего имени (common name)** сертификата на стороне сервера.
* Строка 7 говорит нам, что OpenVPN смог открыть TUN-устройство `tun0`.
* Строки с 8 по 10 перечисляют информацию IPv4, которую сервер передал к этому клиенту и показывают, что IP-адрес и маска сети задаются с помощью стандартной команды Linux `/sbin/ip`.
* Строка 11 снова является волшебной строкой, которая сообщает нам, что VPN-соединение было успешно установлено и теперь мы можем безопасно общаться с сервером OpenVPN. Однако, как мы увидим позже, сообщения об ошибках могут еще не появиться.

## Обнаружение неработающей установки

Установка OpenVPN может не работать по многим причинам. В следующем разделе мы рассмотрим список распространенных сбоев. Во-первых, давайте посмотрим, что отображается в файлах журналов при неудачной попытке подключения. Сбои могут возникать очень рано при попытке подключения или даже после строки `Initialization Sequence Completed`.

Если мы используем неправильный файл `tls-auth`, соединение очень рано оборвется. Это как раз и является причиной использования файла `tls-auth`, поскольку минимизирует нагрузку на наш сервер OpenVPN, когда мошеннические клиенты пытаются получить доступ. Клиент, который пытается подключиться без указания файла `tls-auth`, будет отображаться в журналах сервера следующим образом:

```
16:40:31 Authenticate/Decrypt packet error:
         packet HMAC authentication failed
16:40:31 TLS Error: incoming packet authentication failed from
         [AF_INET]<CLIENT-IP>:49956
16:40:33 Authenticate/Decrypt packet error:
         packet HMAC authentication failed
16:40:33 TLS Error: incoming packet authentication failed from
         [AF_INET]<CLIENT-IP>:49956
16:40:37 Authenticate/Decrypt packet error:
         packet HMAC authentication failed
16:40:37 TLS Error: incoming packet authentication failed from
         [AF_INET]<CLIENT-IP>:49956
16:40:45 Authenticate/Decrypt packet error:
         packet HMAC authentication failed
16:40:45 TLS Error: incoming packet authentication failed from
         [AF_INET]<CLIENT-IP>:49956
16:41:01 Authenticate/Decrypt packet error:
         packet HMAC authentication failed
16:41:01 TLS Error: incoming packet authentication failed from
         [AF_INET]<CLIENT-IP>:49956
```

Об этом клиенте больше ничего не сообщается, поскольку сервер OpenVPN немедленно отклоняет попытку подключения. Из временных меток в файле журнала мы видим, что клиент увеличивает время задержки между попытками соединения с каждым неудачным соединением. Если в течение 60 секунд соединение не может быть установлено, клиент прервет:

```
TLS Error: TLS key negotiation failed to occur within 60 seconds
(check your network connectivity)
TLS Error: TLS handshake failed
```

Второй сбой соединения станет очевидным только после того, как соединение будет успешно инициализировано. Для этого мы указываем использование другого кодирующего шифра на одной стороне, но забываем сделать это на другой. В файле журнала клиента теперь будет отображаться следующее:

```
16:56:20 /sbin/ip link set dev tun0 up mtu 1500
16:56:20 /sbin/ip addr add dev tun0 10.200.0.2/24 broadcast 10.200.0.255
16:56:20 Initialization Sequence Completed
16:56:30 Authenticate/Decrypt packet error: cipher final failed
16:56:40 Authenticate/Decrypt packet error: cipher final failed
```

Таким образом, сначала соединение, кажется, было успешно установлено (строки с 1 по 3), но через 10 секунд шифрование и дешифрование канала данных не удается.

---

**Заметка**

Если бы в этом случае использовался графический интерфейс Windows, значок графического интерфейса стал бы зеленым, но сама VPN не работала бы!

---

Во время инициализации будет сообщено о большинстве проблем конфигурации на стороне сервера или клиента. О проблемах маршрутизации, которые встречаются гораздо чаще, OpenVPN обычно не сообщает. Следовательно, требуются различные методы устранения неполадок.

### Исправление распространенных ошибок конфигурации

При настройке конфигурации OpenVPN есть несколько распространенных ошибок, которые легко допустить. Эти ошибки конфигурации можно условно разделить на четыре категории:

* Сертификат (PKI) ошибки и несоответствия
* Несоответствие опций, таких как `tun` по сравнению с `tap`, шифрование и сжатие
* Недостаточно прав для запуска OpenVPN
* Ошибки маршрутизации

В этом разделе мы рассмотрим первые три из этих категорий. Ошибки маршрутизации будут обсуждаться позже в этой главе.

### Неправильный сертификат CA в конфигурации клиента

Файл конфигурации клиента почти всегда будет содержать три строки, подобные этой:

```
ca ca.crt
cert client.crt
key client.key
```

Эти файлы сертификатов и секретных ключей были созданы в [главе 3](cpater-03.md), _PKI и сертификаты_ и широко используются в последующих главах.
Файл CA, однако, не должен указывать центр сертификации, который использовался для подписи файла сертификата клиента. Это должен быть публичный сертификат центра сертификации, который использовался для подписи сертификата сервера. Если сертификат сервера был подписан другим центром сертификации, клиент откажется подключиться к серверу. Это можно увидеть в файле журнала на стороне клиента:

```
UDPv4 link remote: [AF_INET]<SERVER-IP>:1194
VERIFY ERROR: depth=1, error=self signed certificate in certificate
chain: C=ZA, ST=Enlightenment, L=Overall, O=Mastering OpenVPN,
CN=Mastering OpenVPN, emailAddress=root@example.org
TLS_ERROR: BIO read tls_read_plaintext error: error:14090086:SSL
routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed
TLS Error: TLS object -> incoming plaintext read error
TLS Error: TLS handshake failed
```

В этом случае ошибки не регистрируются на стороне сервера, так как сертификат клиента считается действительным на сервере.

Единственное, что зарегистрируется на сервере, это:

```
<CLIENT-IP>:42472 TLS: Initial packet from
    [AF_INET]<CLIENT-IP>:42472, sid=9a1e4a84 cdbb6926
<CLIENT-IP>:51441 TLS: Initial packet from
    [AF_INET]<CLIENT-IP>:51441, sid=17d3c89b 6999ae97
<CLIENT-IP>:43513 TLS: Initial packet from
    [AF_INET]<CLIENT-IP>:43513, sid=4609202f 4c91c23d
```

Это показывает последовательные попытки подключения, которые сделаны клиентом OpenVPN.

#### Как исправить

Убедитесь, что в файле конфигурации клиента указан правильный файл CA.

### Сертификат клиента не распознан сервером

Если сертификат клиента не распознан сервером - сервер откажет в доступе к нему. Это может произойти, если используется неправильный (или мошеннический) клиентский сертификат или если клиентский сертификат был отозван, а опция `crl-verify` указана в файле конфигурации сервера.

Следующие записи будут отображаться в файле журнала сервера, если неизвестный клиент попытается подключиться к серверу OpenVPN:

```
<CLIENT-IP>:57072 TLS: Initial packet from
    [AF_INET]<CLIENT-IP>:57072, sid=a175f1be 6faed111
<CLIENT-IP>:57072 VERIFY ERROR: depth=0, error=unable to get
    local issuer certificate: C=NL, O=Cookbook, CN=client1,
    name=Cookbook Client, emailAddress=janjust@nikhef.nl
<CLIENT-IP>:57072 TLS_ERROR: BIO read tls_read_plaintext error:
    error:140890B2:SSL routines:SSL3_GET_CLIENT_CERTIFICATE:
    no certificate returned
<CLIENT-IP>:57072 TLS Error: TLS object -> incoming plaintext
    read error
<CLIENT-IP>:57072 TLS Error: TLS handshake failed
```

Сервер не может проверить сертификат клиента, так как он не распознает сертификат CA, который использовался для его подписи. Поэтому отказывается разрешить этому клиенту подключаться.

На стороне клиента никакие сообщения не печатаются в файле журнала в течение 60 секунд, после чего первоначальное рукопожатие прекращается и делается новая попытка подключения:

```
13:24:23 UDPv4 link local: [undef]
13:24:23 UDPv4 link remote: [AF_INET]<SERVER-IP>:1194
13:25:23 TLS Error:
TLS key negotiation failed to occur within
    60 seconds (check your network connectivity)
13:25:23 TLS Error: TLS handshake failed
13:25:23 SIGUSR1[soft,tls-error] received, process restarting
13:25:25 Control Channel Authentication: using
    '/etc/openvpn/movpn/ta.key' as a OpenVPN static key file
13:25:25 UDPv4 link local: [undef]
13:25:25 UDPv4 link remote: [AF_INET]<SERVER-IP>:1194
```

#### Как исправить

Убедитесь, что сертификат клиента распознается сервером. Это можно сделать либо указав соответствующий сертификат CA в файле конфигурации сервера, либо добавив сертификат CA в составленный файл сертификата CA в файле конфигурации сервера:

```
# cat CA1.crt CA2.crt > /etc/openvpn/movpn/ca-stack.pem
```

Далее используйте следующее в конфигурации сервера:

```
ca /etc/openvpn/movpn/ca-stack.pem
```

Таким образом, клиентские сертификаты, подписанные `CA1.crt` или `CA2.crt` будут приняты сервером.

Конечно, если это мошенник, пытающийся подключиться, то более подходящим решением может быть черный список IP-адресов, с которых клиент подключается.

## Несоответствие сертификата клиента и приватного ключа

Если сертификат и закрытый ключ на клиенте не совпадают, то OpenVPN даже не будет пытаться подключиться к серверу. Вместо этого в файле журнала будет напечатана следующая ошибка:

```
Cannot load private key file /etc/openvpn/movpn/client1.key:
error:0B080074:x509 certificate routines:
    X509_check_private_key:key values mismatch
Error: private key password verification failed
Exiting due to fatal error
```

Эта проблема может возникнуть, особенно, когда сертификат и закрытый ключ обновляются; Распространенной ошибкой является использование старого приватного ключа с новым сертификатом.

### Как исправить

Убедитесь, что сертификат клиента и приватный ключ совпадают. Удивительно, но для этого не существует простого в использовании инструмента. Чтобы выяснить, принадлежат ли сертификат и закрытый ключ друг другу - мы можем использовать следующие команды и искать разделы `modulus`:

```
$ openssl x509 -text -noout -in client1.crt
[…]
  Public Key Algorithm: rsaEncryption
  Public-Key: (2048 bit)
  Modulus:
    00:b2:17:bd:31:6d:56:d9:eb:c9:09:98:e2:c1:48:
    c9:6a:e4:4a:6b:54:52:ea:1e:60:94:6b:cb:5e:d5:
    a1:ef:83:05:f8:cf:a4:06:df:06:ee:d6:c8:75:65:
    de:a7:96:68:a1:41:d1:9d:f0:2c:84:3f:ca:b9:d2:
    e8:07:af:37:48:24:69:57:4e:09:70:66:47:6c:47:
    36:4d:c9:29:13:eb:ed:c1:aa:cd:36:84:3c:55:18:
    bc:ce:01:34:b5:89:04:dc:09:c5:ea:f2:57:9f:c2:
    f5:c1:05:dd:66:4d:11:13:05:47:46:26:1a:55:18:
    51:bd:89:65:ba:0d:89:bd:ea:03:58:5e:d3:d9:96:
    a5:5e:2f:5f:b9:c8:88:fc:48:95:cb:4a:b2:12:3b:
    b5:ed:4c:40:4c:50:8d:1d:eb:a5:c9:c0:e6:2c:ec:
    01:0a:56:ac:db:9e:e7:56:f0:06:f7:ba:b6:ac:de:
    41:d4:fb:b3:d6:f5:fe:13:b4:03:81:d9:f7:7c:2e:
    60:2f:9c:5a:81:eb:2e:3a:e1:c4:8b:f8:b6:8d:2d:
    f7:ec:7a:f6:2c:ff:af:1c:d2:7b:58:ca:9e:d1:f4:
    ed:8a:7a:35:00:97:a3:35:dd:79:02:b4:79:9a:66:
    3c:5e:c8:4d:87:eb:68:5d:45:29:73:70:7f:61:28:
    67:b1

$ openssl rsa -text -noout -in client1.key
Private-Key: (2048 bit)
modulus:
    00:b2:17:bd:31:6d:56:d9:eb:c9:09:98:e2:c1:48:
    c9:6a:e4:4a:6b:54:52:ea:1e:60:94:6b:cb:5e:d5:
    a1:ef:83:05:f8:cf:a4:06:df:06:ee:d6:c8:75:65:
    de:a7:96:68:a1:41:d1:9d:f0:2c:84:3f:ca:b9:d2:
    e8:07:af:37:48:24:69:57:4e:09:70:66:47:6c:47:
    36:4d:c9:29:13:eb:ed:c1:aa:cd:36:84:3c:55:18:
    bc:ce:01:34:b5:89:04:dc:09:c5:ea:f2:57:9f:c2:
    f5:c1:05:dd:66:4d:11:13:05:47:46:26:1a:55:18:
    51:bd:89:65:ba:0d:89:bd:ea:03:58:5e:d3:d9:96:
    a5:5e:2f:5f:b9:c8:88:fc:48:95:cb:4a:b2:12:3b:
    b5:ed:4c:40:4c:50:8d:1d:eb:a5:c9:c0:e6:2c:ec:
    01:0a:56:ac:db:9e:e7:56:f0:06:f7:ba:b6:ac:de:
    41:d4:fb:b3:d6:f5:fe:13:b4:03:81:d9:f7:7c:2e:
    60:2f:9c:5a:81:eb:2e:3a:e1:c4:8b:f8:b6:8d:2d:
    f7:ec:7a:f6:2c:ff:af:1c:d2:7b:58:ca:9e:d1:f4:
    ed:8a:7a:35:00:97:a3:35:dd:79:02:b4:79:9a:66:
    3c:5e:c8:4d:87:eb:68:5d:45:29:73:70:7f:61:28:
    67:b1
[…]
```

Если мы посмотрим на модуль с открытого ключа (сертификата) и приватного ключа, то увидим что они одинаковы. Таким образом, этот сертификат и приватный ключ принадлежат друг другу.

---

**Подсказка**

При сравнении модулей часто достаточно сравнить первые несколько байтов, а затем последние несколько байтов.

---

## Несоответствие ключей auth и tls-auth

Параметры `auth` и `tls-auth `используются для аутентификации пакетов канала управления и канала данных с использованием алгоритма подписи HMAC. Значением по умолчанию для алгоритма аутентификации HMAC является `SHA1`, в котором используются 160-битные ключи. Для опции `tls-auth` нет значения по умолчанию, так как оно не требуется. Однако этот вариант рекомендуется, поскольку он обеспечивает дополнительный уровень защиты от DDoS-атак.

Если алгоритм аутентификации, указанный в конфигурации клиента и сервера, не совпадает, то сервер не позволит клиенту начать квитирование безопасности TLS. Аналогичным образом, если файлы `tls-auth` на клиенте и сервере не совпадают или если с обеих сторон указан неверный параметр `direction` - сервер также не позволит клиенту начать квитирование безопасности TLS.

Обычно в файле конфигурации сервера указывается следующая опция:

```
tls-auth /etc/openvpn/movpn/ta.key 0
```

Соответственно, на клиенте у нас есть следующая опция:

```
tls-auth /etc/openvpn/movpn/ta.key 1
```

Здесь второй параметр определяет `direction` из `tls-auth` для используемых ключей. Этот параметр не обязателен, но он позволяет OpenVPN использовать разные ключи хеширования (или HMAC) для входящего и исходящего трафика. Ключ, используемый на клиенте для подписи исходящего трафика, должен совпадать с ключом, используемым на сервере для проверки входящего трафика, и наоборот.

Если используется неверный файл ключей `tls-auth` или если направление опущено или указано неверно, в журнале сервера появятся следующие записи:

```
Authenticate/Decrypt packet error: packet HMAC
    authentication failed
TLS Error: incoming packet authentication failed from
    [AF_INET]<CLIENT-IP>:54377
```

В то же время, клиент просто попытается подключиться в течение 60 секунд, прежде чем произойдет тайм-аут.

### Как исправить

Убедитесь, что используется один и тот же файл `tls-auth` в файлах конфигурации клиента и сервера. Также убедитесь, что параметр `direction` указан правильно на обоих концах (если используется вообще).

Если вы все еще не уверены, какие ключи HMAC используются для входящих и исходящих соединений, то можете увеличить детализацию файла журнала, чтобы увидеть фактические ключи, используемые как клиентом, так и сервером. Давайте добавим следующее в файлы конфигурации клиента и сервера:

```
verb 7
```

Теперь обе стороны будут печатать большое количество информации о регистрации при запуске.

Строки для поиска в файле журнала на на стороне сервера:

```
Outgoing Control Channel Authentication:
    Using 160 bit message hash 'SHA1' for HMAC authentication
Outgoing Control Channel Authentication:
    HMAC KEY: 4660a714 7f4d33f9 d2f7c61a 9f1d5743 4bf9411e
Outgoing Control Channel Authentication:
    HMAC size=20 block_size=20
Incoming Control Channel Authentication:
    Using 160 bit message hash 'SHA1' for HMAC authentication
Incoming Control Channel Authentication:
    HMAC KEY: cd1f6d9c 88db5ec7 d7977322 e01d14f1 26ee4e22
Incoming Control Channel Authentication:
    HMAC size=20 block_size=20
```

Строка `HMAC size = 20` соответствует тому, что используется 160-битовое хеширование с помощью SHA1, так как 160 соответстуют как 20 байт.

Если на стороне клиента используются правильный файл `tls-auth` и параметр `direction`, мы найдем следующее:

```
Outgoing Control Channel Authentication:
    Using 160 bit message hash 'SHA1' for HMAC authentication
Outgoing Control Channel Authentication:
    HMAC KEY: cd1f6d9c 88db5ec7 d7977322 e01d14f1 26ee4e22
Outgoing Control Channel Authentication:
    HMAC size=20 block_size=20
Incoming Control Channel Authentication:
    Using 160 bit message hash 'SHA1' for HMAC authentication
Incoming Control Channel Authentication:
    HMAC KEY: 4660a714 7f4d33f9 d2f7c61a 9f1d5743 4bf9411e
Incoming Control Channel Authentication:
    HMAC size=20 block_size=20
```

Ключи аутентификации входящего и исходящего каналов управления зеркально отображаются на клиенте и на сервере, обеспечивая надлежащую аутентификацию TLS.

## Несоответствие размера MTU

OpenVPN использует два размера **максимальной единицы передачи (MTU)**:

* `tun-mtu`: указывает настройку MTU адаптера `tun` и указывает максимальный размер каждого пакета внутри VPN-туннеля.
* `link-mtu`: указывает максимальный размер каждого пакета вне туннеля. Он включает в себя все биты заполнения, шифрования и аутентификации, но это не фактический размер пакета при передаче по сети. Фактический размер пакета не может быть определен заранее, так как размер каждого пакета может отличаться из-за алгоритмов сжатия и шифрования.

Значение по умолчанию для параметра `tun-mtu` составляет 1500 байт, что также является размером MTU по умолчанию для адаптера Ethernet. При нормальных обстоятельствах мы можем использовать следующую формулу для вычисления размера `link-mtu` из размера `tun-mtu`:

```
link-mtu = tun-mtu + constant
```

Здесь `constant` зависит от используемых параметров конфигурации. Среди параметров конфигурации, которые влияют на эту константу, мы имеем следующие:

* Варианты сжатия, такие как `comp-lzo` и `comp-noadapt`
* Размер **вектора инициализации (IV)** параметра шифрования опции `cipher`
* Опция `fragment`, добавляющая дополнительный байт
* Опция `no-replay`, которая удаляет байт.

Если мы видим несоответствие предупреждений `link-mtu` - это обычно указывает на неправильную конфигурацию в других местах наших файлов конфигурации клиента и сервера. Как вы увидите в последующих примерах, несоответствие в `link-mtu` между клиентом и сервером может происходить довольно часто. Обычно VPN-соединение не будет работать правильно, если имеется несоответствие `link-mtu`.

---

**Подсказка**

Не поддавайтесь искушению исправить само предупреждение `link-mtu` явно установив его. Сначала исправьте другие предупреждения, которые могли вызвать появление предупреждения `link-mtu`.

---

Параметр `link-mtu` также имеет большое значение при настройке VPN-соединения.

Чтобы получить максимальную производительность от VPN-соединения - нам нужно убедиться, что пакеты не фрагментируются операционной системой, поскольку это сильно повлияет на производительность. В частности, для спутниковых каналов это может привести к снижению производительности почти до полной остановки.

Если на стороне сервера указан другой размер MTU по сравнению со стороной клиента, в файлах журнала появится следующее предупреждение:

```
WARNING: 'link-mtu' is used inconsistently,
    local='link-mtu 1441', remote='link-mtu 1541'
WARNING: 'tun-mtu' is used inconsistently,
    local='tun-mtu 1400', remote='tun-mtu 1500'
```

Это показывает, что для конфигурации `default`, издержки `link-mtu` на самом деле составляют 41 байт. Здесь мы добавили в файл конфигурации клиента:

```
tun-mtu 1400
```

На этом этапе VPN-соединение будет функционировать. Однако производительность будет ограничена, так как пакеты должны быть фрагментированы и повторно собраны. При такой настройке можно вызвать ошибку, отправив большие пакеты ICMP с установленным флагом `not fragment `. В Linux/FreeBSD это можно сделать с помощью следующей команды:

```
$ ping -M do -s 1450 10.200.0.2
```

В Windows мы используем следующее:

```
C:\> ping -f -l 1450 10.200.0.2
```

Это приведет к 100-процентной потере пакета для команды `ping`, а также будет отображаться в файле журнала:

```
Authenticate/Decrypt packet error:
    packet HMAC authentication failed
```

Это сообщение об ошибке может сначала показаться странным, но оно вызвано тем, что отправляющая сторона создала и подписала пакет, размер которого превышает 1400 байт. Клиент получает только первые 1400 байтов этого пакета и проверяет подпись, которая терпит неудачу. Затем он отклоняет пакет и распечатывает ошибку.

### Как исправить

Убедитесь, что, если вы хотите использовать опцию `tun-mtu` - она указана в файлах конфигурации клиента и сервера.

## Несоответствие шифра

Шифр кодирования, который используется для канала данных OpenVPN, можно указать, используя следующую опцию со значением по умолчанию `BF-CBC`:

```
cipher aes-256-cbc
```

Если в файле конфигурации клиента указан другой шифр, чем в файле конфигурации сервера, то в файлах журнала с обеих сторон будет напечатано предупреждающее сообщение, но VPN-соединение будет установлено. Однако, как только любой трафик проходит по нему, он не сможет расшифровать. Мы можем видеть это в следующем фрагменте из файла журнала на стороне клиента:

```
WARNING: 'link-mtu' is used inconsistently,
    local='link-mtu 1557', remote='link-mtu 1541'
WARNING: 'cipher' is used inconsistently,
    local='cipher AES-256-CBC', remote='cipher BF-CBC'
WARNING: 'keysize' is used inconsistently,
    local='keysize 256', remote='keysize 128'
[Mastering OpenVPN Server] Peer Connection Initiated
    with [AF_INET]<SERVER-IP>:1194
TUN/TAP device tun0 opened
do_ifconfig, tt->ipv6=0, tt->did_ifconfig_ipv6_setup=0
/sbi/nip link set dev tun0 up mtu 1500
/sbi/nip addr add dev tun0 10.200.0.2/24 broadcast 10.200.0.255
Initialization Sequence Completed
Authenticate/Decrypt packet error: cipher final failed
```

Три напечатанных предупреждения изначально показывают как другой тип, так и другой размер используемого шифра. Шифр Blowfish по умолчанию использует 128-битную стойкость, тогда как AES-256 - 256-битную стойкость, что приводит к немного большему зашифрованному пакету (`link-mtu` 1541 байт для Blowfish по сравнению с `link-mtu` 1557 байт для AES-256).

### Как исправить

Убедитесь, что в файлах конфигурации клиента и сервера указан один и тот же шифр. Поскольку файлы журналов клиента и сервера выводят ожидаемый шифр, исправить эту ошибку довольно просто.

---

**Заметка**

В настоящее время невозможно передать шифр с сервера на клиент. Это в списке пожеланий разработчиков OpenVPN, но оно оказывает существенное влияние на код. Он не будет добавлено в OpenVPN до версии 2.4 или даже 2.5.

## Несоответствие компрессии

OpenVPN имеет возможность сжимать весь VPN-трафик на лету. Для определенных типов трафика, таких как обычный веб-трафик, это может повысить производительность VPN, но добавляет дополнительные издержки к протоколу VPN. Для несжимаемого трафика эта опция фактически немного снижает производительность.

Параметр, используемый для указания сжатия в настоящее время, выглядит следующим образом:

```
comp-lzo [no|yes|adaptive]
```

Обратите внимание, что нам не нужно указывать второй параметр. Значение по умолчанию является адаптивным, если используется сжатие.

Как мы узнаем в [Главе 10](chapter010.md), _Будущие направления_ , этот вариант будет заменен более общим вариантом `compression`, что позволит различные механизмы сжатия.

Можно передать опцию `compression` с сервера на клиент, но только если опция сжатия была указана в самом файле конфигурации клиента. Если файл конфигурации клиента не содержит такой опции, VPN-соединение не будет установлено. В файле журнала клиента будет показано следующее:

```
UDPv4 link remote: [AF_INET]<SERVER-IP>:1194
WARNING: 'link-mtu' is used inconsistently,
    local='link-mtu 1541', remote='link-mtu 1542'
WARNING: 'comp-lzo' is present in remote config but
    missing in local config, remote='comp-lzo'
[Mastering OpenVPN Server] Peer Connection Initiated with
    [AF_INET]<SERVER-IP>:1194
TUN/TAP device tun0 opened
do_ifconfig, tt->ipv6=0, tt->did_ifconfig_ipv6_setup=0
sbinip link set dev tun0 up mtu 1500
sbinip addr add dev tun0 10.200.0.2/24 broadcast 10.200.0.255
Initialization Sequence Completed
write to TUN/TAP : Invalid argument (code=22)
```

Файл журнала сервера будет содержать те же сообщения `WARNING`, а также будет отображать предупреждения распаковки:

```
client3/<CLIENT-IP>:45113 Bad LZO decompression header byte: 42
```

---

**Заметка**

Странно, но верно: если мы будем ждать достаточно долго, клиент будет перезагружен из-за ошибок сжатия и попытается восстановить соединение. На этот раз, однако, соединение будет успешным, так как опция `comp-lzo` все еще находится в памяти.

---

### Как исправить

Убедитесь, что, если вы хотите использовать сжатие, опция `comp-lzo` указана в файлах конфигурации клиента и сервера. С опцией `comp-lzo` в файле конфигурации на стороне клиента мы теперь можем контролировать тип сжатия, используемый на стороне сервера, используя опцию `push`. Используйте следующее:

```
comp-lzo no
push "comp-lzo no"
```

Это отключит сжатие, но, к сожалению, это не то же самое, что вообще не указывать какой-либо метод сжатия. Надеемся, что это будет решено в будущем выпуске.

## Несоответствие фрагмента

Одним из наиболее часто используемых параметров настройки является опция `fragment`. Подробнее об этой опции вы узнаете в разделе _Как оптимизировать производительность с помощью ping и iperf_ далее в этой главе.

Как и параметр `comp-lzo`, параметр `fragment` указывать не нужно ни с одной стороны. Однако мы не можем указать его только с одной стороны; он должен быть настроен на обоих. Если он указан только с одной стороны, то также должен быть указан и с другой. Технически говоря, даже нет необходимости использовать одно и то же значение для параметра `fragment` с обеих сторон, но это рекомендуется.

Если опция `fragment` не указана на стороне клиента, но используется на стороне сервера, то VPN-соединение не будет работать должным образом, как видно из журнала клиента:

```
WARNING: 'link-mtu' is used inconsistently,
  local='link-mtu 1541', remote='link-mtu 1545'
WARNING: 'mtu-dynamic' is present in remote config but
  missing in local config, remote='mtu-dynamic'
[Mastering OpenVPN Server] Peer Connection Initiated with
  [AF_INET]194.171.96.101:1194
TUN/TAP device tun0 opened
do_ifconfig, tt->ipv6=0, tt->did_ifconfig_ipv6_setup=0
sbinip link set dev tun0 up mtu 1500
sbinip addr add dev tun0 10.200.0.2/24 broadcast 10.200.0.255
Initialization Sequence Completed
write to TUN/TAP : Invalid argument (code=22)
```

Опять же, это будет выглядеть так, как будто VPN подключился (`Initialization sequence completed`), но файл журнала заполнится сообщениями об ошибках с `code=22 `.

Обратите внимание, что в предупреждении фактически указан `mtu-dynamic`, который является устаревшим названием этой функции.

### Как исправить

Убедитесь, что, если вы хотите использовать параметр `fragment` - он указывается в файлах конфигурации клиента и сервера.

Обратите внимание, что, в отличие от опции `comp-lzo`, эту функцию нельзя передать с сервера на клиент.

## Несоответствие tun и tap

Наиболее распространенный вариант использования сети в стиле tap - это мостовая установка, как мы узнали из [Главы 6](chapter-06.md) , _Режим клиент /сервер с помощью tap-устройств_. Однако не все устройства поддерживают сеть в стиле tap. В частности, все устройства Android и iOS не имеют этой возможности. Следовательно, если мы подключим такое устройство к серверу OpenVPN в стиле tap, в файле журнала сервера будут перечислены предупреждения от этих клиентов:

```
<CLIENT-IP>:39959 WARNING: 'dev-type' is used inconsistently,
    local='dev-type tap', remote='dev-type tun'
<CLIENT-IP>:39959 WARNING: 'link-mtu' is used inconsistently,
    local='link-mtu 1573', remote='link-mtu 1541'
<CLIENT-IP>:39959 WARNING: 'tun-mtu' is used inconsistently,
    local='tun-mtu 1532', remote='tun-mtu 1500'
```

Помимо этих предупреждений сервер не обнаружит ничего о подключающихся клиентах. На клиенте аналогичные предупреждения будут перечислены вместе с этим:

```
WARNING: Since you are using --dev tun with a point-to-point
topology, the second argument to --ifconfig must be an IP address.
You are using something (255.255.255.0) that looks more like a
netmask. (silence this warning with --ifconfig-nowarn)
```

Так как мы не можем передать топологию подсети в настройке стиля tap, клиент возвращается к сети по умолчанию в стиле Net30. Этот тип сети по своей сути несовместим с сетью в стиле tap, но, кроме этого, клиент не выдает никаких предупреждений или ошибок.

Даже если бы мы (ошибочно) добавили `topology subnet` для подавления этого предупреждения на клиенте, VPN все равно не работал бы правильно.

### Как исправить

Убедитесь, что с обеих сторон используется один и тот же тип сети (tun или tap). Если вам необходимо использовать устройства Android или iOS - вы должны настроить конфигурацию сервера в стиле tun, так как эти операционные системы не поддерживают сеть в стиле tap.

### Проблемы с client-config-dir

В [Главе 4](chapter-04.md), _Режим клиент/сервер с TUN устройствами_, мы узнали о CCD-файлах и их использование в разделе _Специфичная для клиента конфигурация - файлы CCD_. Файлы CCD обычно используются для подключения клиентской локальной сети к сети сервера с помощью оператора `iroute`.

Опыт работы со списками рассылки и форумами OpenVPN показал, что опция `client-config-dir` подвержена ошибкам и неправильной настройке. Вот три основные причины этого:

* Файл CCD или каталог, в котором он находится, не может быть прочитан OpenVPN после переключения на `safe` пользователя, такого как `nobody`.
* Опция `client-config-dir` указана без абсолютного пути.
* Имя файла CCD указано неверно. Обычно имя файла CCD совпадает с именем из поля `/CN=` сертификата клиента, без части `/CN=` и без какого-либо расширения!

При нормальном уровне журнала OpenVPN не жалуется, если не может найти или прочитать файл CCD. Он просто обрабатывает входящее соединение как стандартное соединение, и, таким образом, требуемый оператор `iroute` никогда не достигается.

Самый простой способ отладки - это временно добавить дополнительную опцию в конфигурацию сервера:

```
ccd-exclusive
```

Перезагрузите сервер и клиент попытается восстановить соединение. Если сервер не может прочитать соответствующий файл CCD для подключающегося клиента - он откажет в доступе. Если это произойдет - мы знаем, что файл CCD не был прочитан. Если клиент может подключиться, то возникает другая проблема - скорее всего, проблема маршрутизации.

Другой способ увидеть что сервер OpenVPN делает с файлами CCD - это повысить уровень журнала до 4 и повторно подключить клиента, для которого указан файл CCD. Содержимое этого CCD-файла для клиента с сертификатом `/CN=client1` выглядит следующим образом:

```
ifconfig-push 10.200.0.99 255.255.255.0
iroute 192.168.4.0 255.255.255.0
```

Это дает команду серверу OpenVPN назначить IP-адрес VPN `10.200.0.99` для этого клиента и для маршрутизации подсети `192.168.4.0./24` через него. Файл журнала сервера теперь содержит следующее:

```
<CLIENT-IP>:38876 [client1] Peer Connection Initiated with
[AF_INET]<CLIENT-IP>:38876
client1/<CLIENT-IP>:38876 OPTIONS IMPORT: reading client specific
options from: /etc/openvpn/movpn/clients/client1
client1/<CLIENT-IP>:38876 MULTI: Learn: 10.200.0.99 ->
client1/<CLIENT-IP>:38876
client1/<CLIENT-IP>:38876 MULTI: primary virtual IP for
client1/<CLIENT-IP>:38876: 10.200.0.99
client1/<CLIENT-IP>:38876 MULTI: internal route 192.168.4.0/24 ->
client1/<CLIENT-IP>:38876
client1/<CLIENT-IP>:38876 MULTI: Learn: 192.168.4.0/24 ->
client1/<CLIENT-IP>:38876
```

Если выделенная строка отсутствует, то файл CCD не читается. Также следующие строки, начинающиеся с `MULTI:` показывают как сервер OpenVPN интерпретирует строки, найденные в файле CCD. Это может быть важно для дальнейшей отладки любых вопросов `iroute`.

### Как исправить

Если процесс сервера не может прочитать файл CCD - проверьте права доступа к полному пути к файлу, включая все подкаталоги, ведущие к нему. Убедитесь, что пользователь, указанный в параметре `user`, имеет разрешение на чтение всех каталогов и самого файла CCD.

Убедитесь, что в опции `client-config-dir` указан абсолютный путь вместо относительного. Кроме того, если мы используем опцию `chroot` (подробности см. в man), убедитесь, что директория `client-config-dir` видна внутри `chroot-jail`.

Используйте опцию `ccd-exclusive` чтобы быстро определить, может ли OpenVPN читать файл CCD. Если это возможно, то увеличьте уровень журнала на стороне сервера, чтобы увидеть, как OpenVPN интерпретирует операторы, найденные в файле CCD.

## Нет доступа к устройству tun в Linux

Если OpenVPN запускается с недостаточными привилегиями или если OpenVPN настроен на удаление привилегий root и переключение на другой `userid` (например, `nobody`), то доступ к устройству tun может быть потерян. Это также может произойти, если OpenVPN используется в виртуализированной среде, такой как OpenVZ или **Virtual Private Server (VPS)**.

Если OpenVPN запущен с недостаточными привилегиями - VPN-соединение вообще не будет установлено:

```
UDPv4 link local: [undef]
UDPv4 link remote: [AF_INET]<SERVER-IP>:1194
[Mastering OpenVPN Server] Peer Connection Initiated with
    [AF_INET]<SERVER-IP>:1194
ERROR: Cannot ioctl TUNSETIFF tun: Operation not permitted
    (errno=1)
Exiting due to fatal error
```

Проверьте `userid` или используйте `sudo` для переключения на привилегированного пользователя перед запуском OpenVPN.

Наиболее распространенный сценарий, когда доступны недостаточные привилегии, происходит после автоматического перезапуска VPN-подключения. Рассмотрим следующий файл конфигурации клиента:

```
client
proto udp
remote openvpnserver.example.com
port 1194
dev tun
nobind

remote-cert-tls server
tls-auth  /etc/openvpn/movpn/ta.key 1
ca        /etc/openvpn/movpn/movpn-ca.crt
cert      /etc/openvpn/movpn/client3.crt
key       /etc/openvpn/movpn/client3.key

user nobody
group nobody
```

Это базовый файл конфигурации с двумя строками внизу. Когда мы запускаем VPN-соединение с помощью этого файла конфигурации, соединение устанавливается правильно, но выводится предупреждение:

```
WARNING: you are using user/group/chroot/setcon without persist-tun
-- this may cause restarts to fail
```

Действительно, после перезапуска VPN-соединения (например, из-за плохого сетевого соединения) перезапуск не удастся:

```
[Mastering OpenVPN Server] Inactivity timeout (--ping-restart), restarting
Mon Jun 1 16:51:50 2015 sbinip addr del dev tun0 10.200.0.2/24
RTNETLINK answers: Operation not permitted
Linux ip addr del failed: external program exited with error status: 2
SIGUSR1[soft,ping-restart] received, process restarting
WARNING: you are using user/group/chroot/setcon without persist-key -- this may cause restarts to fail
Error: private key password verification failed
Exiting due to fatal error
```

Здесь мы видим, что OpenVPN не удалось перезапустить, так как пользователю `nobody` не разрешили прочитать приватный ключ, который использовался для этого соединения. Если бы мы указали пользователя с правами доступа, мы бы увидели другую ошибку:

```
ERROR: Cannot ioctl TUNSETIFF tun: Operation not permitted
    (errno=1)
Exiting due to fatal error
```

Обратите внимание, что во время перезапуска OpenVPN не может завершить работу существующего устройства tun или удалить любые системные маршруты. Это также будет иметь место, если используется `persist-tun`, но в этом случае он будет безвредным.

### Как исправить

Добавьте следующие параметры в файл конфигурации клиента, если вы также используете параметры `user` и/или `group`:

```
persist-tun
persist-key
```

Убедитесь, что вы запускаете OpenVPN с достаточными привилегиями.

Также убедитесь, что OpenVPN имеет правильный контекст безопасности SELinux, или попробуйте запустить OpenVPN с SELinux, установленным в разрешающий или отключенный режим:

```
# setenforcing permissive
```
<!--
## Отсутствие повышенных привилегий в Windows

В некоторых старых версиях программы установки OpenVPN для Windows не были заданы правильные привилегии для приложения OpenVPN GUI.

В этом конкретном примере один сервер был отправлен с сервера OpenVPN всем клиентам:

нажать «маршрут 192.168.122.0 255.255.255.0»

В Windows Vista и выше OpenVPN требуются повышенные привилегии, чтобы иметь возможность добавлять или удалять системные маршруты. Если эти привилегии отсутствуют, VPN обычно инициализируется правильно, а значок GUI становится зеленым:













Мы даже можем пропинговать сервер OpenVPN по IP-адресу его VPN-сервера. Тем не менее, файл журнала в OpenVPN GUI покажет некоторые ошибки:


















Первая строка на самом деле сложно:

Предупреждение: не удается открыть файл -log: .....: доступ запрещен

Сложность в том, что как только мы нажимаем кнопку « Отключить» , журнал исчезает, так как он не может быть записан на диск! Это вызвано тем, что каталог журналов по умолчанию C: \ Program Files \ OpenVPN \ log доступен только пользователю с повышенными привилегиями.

Последние несколько строк в файле журнала говорят нам, что OpenVPN не удалось добавить маршрут, который был выдвинут сервером. Опять же, это связано с тем, что программа OpenVPN была запущена с недостаточными привилегиями.

Как исправить

После перезапуска графического интерфейса OpenVPN с повышенными правами (включите Запуск от имени администратора ), маршрут будет добавлен правильно. Это видно из таблицы маршрутизации :






















Выдвинутый маршрут, 192.168.122.0/24 , теперь присутствует в таблице маршрутизации, используя IP-адрес VPN сервера 10.200.0.1 в качестве шлюза.
Устранение проблем с маршрутизацией

Большинство вопросов, задаваемых в списках рассылки OpenVPN и форумах пользователей, на самом деле являются вопросами маршрутизации. Настройка VPN-соединения - это одно, а интеграция в существующую сеть - совсем другое. Для новичка трудная часть состоит в том, чтобы видеть, где останавливается OpenVPN и где начинается маршрутизация. Этот раздел предназначен в качестве пошагового руководства по устранению неполадок маршрутизации в довольно простой настройке OpenVPN.

Рассмотрим следующий план сети:

 Сеть в главном офисе должна быть доступна для дополнительного офиса и для людей, работающих из дома
 Серверы в дополнительном офисе должны быть доступны для ИТ-отдела главного офиса
 Люди, работающие из дома, должны иметь доступ только к компьютерным ресурсам в главном офисе.

Для этого в главном офисе устанавливается сервер OpenVPN, сотрудники которого подключаются как обычные клиенты VPN, а дополнительный офис подключается как специальный клиент, раскрывая свою собственную сеть.
Рисование детальной картины

Перед созданием файлов конфигурации для OpenVPN нарисуйте подробное изображение схемы сети, включая все подсети, IP-адреса, IP-адреса шлюза, имена интерфейсов и многое другое.













Используемые публичные IP-адреса не перечислены на этом рисунке, но это рекомендуется сделать. Кроме того, подключения от людей, работающих из дома, не включены, но они будут подключаться к общедоступному IP-адресу шлюза1 на предыдущем рисунке.

На шлюзе 1 добавлено правило переадресации портов, поэтому входящий и исходящий трафик UDP через порт 1194 перенаправляется на сервер OpenVPN в 172.31.1.2:1194 .

Поскольку нам необходимо раскрыть сеть в дополнительном офисе, нам также потребуется использовать файл client-config-dir с соответствующим оператором iroute .

Файлы конфигурации сервера и клиента для этой настройки уже перечислены в Главе 4 , Режим клиент / сервер с устройствами Tun , с некоторыми незначительными изменениями IP-адреса . Новый набор файлов конфигурации выглядит следующим образом:

прото удп
порт 1194
Dev Tun
сервер 10.200.0.0 255.255.255.0
tls-auth и т. д. openvpn / movpn / ta.key 0
и т. д. openvpn / movpn / dh2048.pem
и т. д. openvpn / movpn / movpn-ca.crt
сертификат и т. д. openvpn / movpn / server.crt
и т. д. openvpn / movpn / server.key
упорствовать-ключ
упорствовать-чан
keepalive 10 60
подсеть топологии
пользователь никто
никто не группа
глагол 3

демон

log-append var log / openvpn.log

push "route 172.31.1.0 255.255.255.0" client-config-dir и т. д. openvpn / movpn / clients route 192.168.3.0 255.255.255.0 10.200.0.1

Этот файл сохраняется как movpn-09-01-server.conf . Для клиента OpenVPN в дополнительном офисе создается специальный сертификат с именем / CN = SecondaryOffice . Соответствующий файл CCD, следовательно, имеет имя
и т. д. openvpn / movpn / clients / SecondaryOffice . Его содержание таково:

ifconfig-push 10.200.0.200 255.255.255.0 iroute 192.168.3.0 255.255.255.0

Для всех клиентов: basic-udp-client.conf или basic-udp-client.ovpn

Конфигурационный файл может быть использован. Это, кстати, показывает гибкость конфигурационных файлов OpenVPN. В большинстве случаев нет необходимости изменять файлы конфигурации клиента, даже если макет сети на стороне сервера был изменен или в VPN была добавлена ​​вторичная сеть.

Затем мы запускаем сервер OpenVPN и клиент вторичного офиса и проверяем, что файл CCD выбран. Клиент VPN на вторичном офисе может пинговать сервер OpenVPN на его VPN IP - адрес, и поэтому может тест пользователь дома.

Заметка

На данный момент VPN работает, а маршрутизация - нет.
Начните с середины и двигайтесь наружу

Наиболее эффективный способ устранения неполадок в этой настройке состоит в том, чтобы рассматривать канал VPN как середину, а затем постепенно выполнять пошаговую работу до тех пор, пока все части сети не будут подключены. Во-первых, есть несколько тестов для выполнения на клиенте OpenVPN в дополнительном офисе. Почти для всех тестов достаточно простой команды ping .

Обратите внимание, что нет смысла переходить ко второму тесту, если первый тест не пройден, и аналогично к третьему тесту, если второй тест еще не работает:

 Может ли клиент достичь IP-адреса VPN сервера?

Это должно функционировать; в противном случае существует проблема с нашим VPN. Это может быть очень ограниченная настройка брандмауэра / iptables на сервере. IP-адрес VPN-сервера должен быть закрытым (как правило, RFC1918) и, следовательно, не будет маршрутизируемым через общий Интернет.

 Может ли клиент получить доступ к IP-адресу сервера в локальной сети?

Если это не работает, то, скорее всего, существует правило брандмауэра или iptables, которое блокирует доступ. Проверьте входящие правила или попробуйте отключить правила брандмауэра для отладки.
 Может ли клиент достичь IP-адреса шлюза на стороне сервера?

Если нет, то проверьте ответы на следующие вопросы:

 На сервере включена переадресация IP?
 Существует ли правило брандмауэра / iptables, блокирующее перенаправление доступа к серверу с определенного диапазона IP-адресов?
 Существует ли на межсетевом шлюзе правило брандмауэра, блокирующее доступ с IP-адресов, не относящихся к локальной сети? (Это было бы хорошей политикой безопасности.) Если это так, то ее необходимо настроить, чтобы разрешить трафик, поступающий с VPN IP 10.200.0.0/24.
 Есть ли обратный маршрут на шлюзе, чтобы сообщить, куда должны возвращаться пакеты, исходящие из VPN? Пакеты с адресом назначения в диапазоне 10.200.0.0/24 следует пересылать на сервер OpenVPN по IP 172.31.1.2 на шлюзе маршрутизатора1 . Обратите внимание, что это обычно не так. Фактический синтаксис для добавления такого маршрута к шлюзу зависит от модели и встроенного программного обеспечения используемого маршрутизатора.
 Может ли клиент связаться с другим сервером в локальной сети на стороне сервера?

Если нет, то проверьте ответы на следующие вопросы:
 Имеет ли этот сервер в локальной сети на стороне сервера правильный шлюз в качестве шлюза по умолчанию?
 Существует ли на сервере правило брандмауэра, блокирующее доступ с IP-адресов, не относящихся к локальной сети? (На самом деле это будет хорошая политика безопасности!)

Убедившись, что клиент может получить доступ ко всем машинам в локальной сети на стороне сервера, пришло время убедиться, что обратное также верно. Убедитесь, что сервер OpenVPN может получить доступ ко всем машинам в локальной сети за вторичным клиентом. Тесты для выполнения очень похожи:

 Может ли сервер достичь IP-адреса VPN клиента?

Это должно функционировать; в противном случае существует проблема с нашим VPN. Это может быть очень ограниченная настройка брандмауэра / iptables на клиенте. Тем не менее, на данный момент это вряд ли будет проблемой. Хотя лучше, чем потом сожалеть, так что давайте проверим это.

 Может ли сервер получить доступ к IP-адресу локальной сети клиента?

Если это не работает, то, скорее всего, существует правило брандмауэра / iptables, которое блокирует доступ. Проверьте входящие правила.
 Может ли сервер достичь IP-адреса шлюза на стороне клиента?

Если нет, то проверьте ответы на следующие вопросы:

 Включена ли переадресация IP на клиенте вторичного офиса?

Существует ли правило брандмауэра / iptables, блокирующее перенаправление доступа на клиенте из определенного диапазона IP-адресов?

 Есть ли на клиентском шлюзе правило брандмауэра, блокирующее доступ с IP-адресов не из локальной сети? (Это было бы хорошей политикой безопасности.) Если это так, то ее необходимо отрегулировать так, чтобы трафик приходил с VPN IP
10.200.0.1 .

 Есть ли обратный маршрут на шлюзе во вторичном офисе, чтобы сообщить ему, куда должны возвращаться пакеты, исходящие из VPN? Пакеты с адресом источника 10.200.0.1 должны быть перенаправлены клиенту OpenVPN по IP 192.168.3.17 на шлюзе маршрутизатора2 . Обратите внимание, что это обычно не так. Фактический синтаксис для добавления такого маршрута к шлюзу зависит от модели и встроенного программного обеспечения используемого маршрутизатора. Также обратите внимание, что мы разрешаем проходить только пакетам с самого сервера OpenVPN, так как все остальные клиенты не требуют доступа к нему.
сеть.

 Может ли сервер OpenVPN подключиться к другому компьютеру в локальной сети на стороне клиента?

Если нет, то проверьте ответы на следующие вопросы:

 Имеет ли этот сервер в локальной сети на стороне клиента надлежащий шлюз в качестве шлюза по умолчанию?
 Существует ли на сервере правило брандмауэра, блокирующее доступ с IP-адресов, не относящихся к локальной сети? (На самом деле это будет хорошая политика безопасности!)

На этом этапе клиент OpenVPN в дополнительном офисе должен иметь доступ ко всем машинам в локальной сети на стороне сервера, а сервер OpenVPN в главном офисе должен иметь доступ ко всем машинам в локальной сети на стороне клиента. Есть только еще один шаг: убедитесь, что серверы в локальной сети на стороне сервера могут обращаться к серверам в локальной сети на стороне клиента и наоборот. Опять же, нужно выполнить четыре теста, начиная с компьютера в локальной сети на стороне сервера:

 Может ли эта машина достичь IP-адреса VPN клиента OpenVPN?

Это должно работать, так как клиент может достичь этой машины в результате четвертого теста. Тем не менее, лучше, чем потом сожалеть, так что давайте проверим это.
 Может ли этот аппарат получить доступ к IP-адресу локальной сети клиента?

Если это не работает, то, скорее всего, существует правило брандмауэра или iptables, которое блокирует доступ. Проверьте входящие правила на клиенте OpenVPN. Может ли сервер локальной сети достичь IP-адреса шлюза на стороне клиента?

Если нет, то проверьте ответы на следующие вопросы:

 Включена ли переадресация IP на клиенте вторичного офиса? Существует ли правило брандмауэра / iptables, блокирующее перенаправление доступа на клиенте для определенного диапазона IP-адресов? Обратите внимание, что пакеты, поступающие с компьютера в локальной сети на стороне сервера, будут иметь адрес источника ( 172.31.1.X ), отличный от адреса самого сервера OpenVPN ( 10.200.0.1 ).
 Есть ли на клиентском шлюзе правило брандмауэра, блокирующее доступ с IP-адресов, не относящихся к локальной сети? (Это было бы хорошей политикой безопасности.) Если это так, то ее необходимо настроить, чтобы разрешить трафик, поступающий из диапазона IP-адресов локальной сети 172.31.1.0/24 . Точно так же может потребоваться добавить правило брандмауэра на шлюзе на стороне сервера, чтобы разрешить трафик, поступающий из диапазона IP-адресов локальной сети 192.168.3.0/24 на стороне клиента .
 Есть ли обратный маршрут на шлюзе во вторичном офисе, чтобы сообщить ему, куда должны возвращаться пакеты, исходящие из VPN? Пакеты с адресом источника 172.31.1.0/24 должен быть перенаправлен клиенту OpenVPN по IP 192.168.3.17 на шлюзе маршрутизатора2 . Обратите внимание, что это обычно не так.
 Может ли сервер на стороне сервера подключиться к другому компьютеру на стороне клиента?

Если нет, то проверьте ответы на следующие вопросы:

 Имеет ли сервер в локальной сети на стороне клиента надлежащий шлюз в качестве шлюза по умолчанию?
 Существует ли на клиентском компьютере правило брандмауэра, блокирующее доступ с IP-адресов, не относящихся к локальной сети? (На самом деле это будет хорошая политика безопасности!)

Методично прорабатывая все эти шаги, мы можем решить практически все проблемы с маршрутизацией. В некоторых случаях могут потребоваться более продвинутые методы отладки. Это может потребовать от нас временного отключения правил брандмауэра, поэтому перед тем, как это предпринять, следует соблюдать особую осторожность.
Найдите время, чтобы временно отключить брандмауэр

В списках рассылки OpenVPN было слишком много случаев, когда люди не могли настроить маршрутизацию на работу, где это оказалось брандмауэром или правилом iptables, которое было слишком ограничительным. Нет необходимости отключать все правила брандмауэра, но если вы застряли на одном из двенадцати шагов, перечисленных ранее, попробуйте отключить брандмауэр, связанный с устройством, к которому вы не можете подключиться или с которого вы отправляете трафик.

Заметка

Если вам нужно использовать настройку NATted, убедитесь, что вы не отключаете правила NATting.
Если ничего не помогает, используйте tcpdump

Низкоуровневый сетевой инструмент tcpdump - отличный инструмент для проверки подключения. Для устранения проблем с маршрутизацией мы можем использовать tcpdump, чтобы увидеть, поступает ли какой-либо трафик в конкретный сетевой интерфейс или покидает его, и мы можем проверить адреса источника и назначения этого трафика. На клиенте или сервере Windows может быть проще запустить Wireshark ( http://www.wireshark.org ), который предоставляет аналогичные функции, включая графический интерфейс.

В двенадцати шагах, перечисленных ранее, могут помочь следующие операторы tcpdump :

    1.  Запустите tcpdump -nnel -i tun0 на сервере, чтобы увидеть, поступает ли вообще какой-либо трафик через VPN.

    2.  Запустите tcpdump -nnel -i eth0 на сервере (где eth0 - интерфейс локальной сети используемого сервера), чтобы увидеть, поступает ли вообще какой-либо трафик на интерфейс локальной сети. Если нет, то, скорее всего, правило брандмауэра отбрасывает входящий трафик на туннельном интерфейсе.

    3.  Запустите tcpdump -nnel -i eth0 на сервере, чтобы проверить, покидает ли трафик интерфейс LAN с помощью следующего:

адрес источника
= 10.200.0.200

адрес назначения = 172.31.1.254

Также проверьте, видим ли мы обратный трафик от серверного шлюза с обратными адресами отправителя и получателя.

    4.  Снова запустите tcpdump -nnel -i eth0 на сервере, чтобы проверить, покидает ли трафик интерфейс локальной сети со следующими заголовками пакетов:

адрес источника
= 10.200.0.200

адрес назначения = 172.31.1.XXX

Здесь 172.31.1.XXX - это IP-адрес компьютера , к которому мы пытаемся подключиться в локальной сети на стороне сервера. Есть ли обратный трафик?


И так далее и так далее для оставшихся шагов!
Как оптимизировать производительность с помощью ping и iperf

Получить максимальную производительность из установки OpenVPN может быть сложно. В чистой сети Ethernet стандартные настройки OpenVPN довольно хороши. Однако в гигабитных сетях требуется некоторая настройка.

Когда используется ADSL или кабельное модемное соединение, производительность также обычно довольно хорошая. Однако при определенных обстоятельствах производительность нашего туннеля OpenVPN может значительно отставать от производительности обычной сети. Эти обстоятельства почти всегда зависят от интернет-провайдера, но, тем не менее, стоит изучить, как повысить производительность.

Ключом к оптимизации производительности является наличие хороших инструментов для измерения производительности. Два основных, но бесценных инструмента для измерения производительности сети - это ping и iperf . Инструмент iperf легко доступен в Linux, FreeBSD и Mac OS. Есть порты, доступные для Windows и даже Android.
Используя пинг

Используя ping , мы можем определить оптимальный размер MTU для нашей сети. Большинство сетевых операторов сейчас предоставляют своим клиентам MTU в стиле Ethernet размером 1500 байт. Это приводит к полезной нагрузке пакета в 1472 байта. Остальные 28 байтов являются издержками TCP / IP для таких вещей, как адрес источника и назначения.

Однако если между клиентом и сервером существует сеть с более низким MTU, то это может значительно повысить производительность, уменьшив размер пакетов OpenVPN чуть ниже этого размера. Чтобы определить максимальный размер передачи для нашей сети, мы используем следующее:

$ ping -M do -s 1472 www.example.org

В Windows мы используем следующее:

C: \> ping -f -l 1472 www.example.org

Это будет отправлять ICMP-пакеты на удаленный сервер по нашему выбору с установленным флагом « не фрагментировать» , инструктируя сетевые маршрутизаторы не разбивать этот пакет на более мелкие биты. Если между клиентом и сервером есть сеть с меньшим MTU, то команда ping завершится неудачно:

$ ping -M do -s 1472 www.example.org

PING www.example.org (IP) 1472 (1500) байт данных.

ping: локальная ошибка: сообщение слишком длинное, mtu = 1480

Это говорит нам о том , что производительность будет , скорее всего , улучшится , если мы используем либо фрагмент размером 1480 или размер MTU, которое 1,480 байт вместо по умолчанию значение 1500 . Обратите внимание, что это не является гарантией - только измерив фактическую производительность VPN, мы узнаем, какое влияние на самом деле.
Использование iperf

Используя iperf , мы можем измерить производительность сети как внутри, так и вне VPN-туннеля. Это даст нам ценную информацию о том, сколько пропускной способности мы тратим, используя VPN-туннель.

Прежде чем измерять производительность самого VPN-туннеля, всегда пытайтесь измерить производительность нормальной сети. Будет довольно сложно заставить VPN работать лучше, чем базовая сеть.

Сначала запустите iperf на сервере с помощью следующей команды:

$ iperf -s

Затем запустите iperf на клиенте с помощью следующей команды:

$ iperf -c openvpn.example.org

В кабельной сети, которая использовалась для тестирования, результат выглядит следующим образом:














Это на самом деле скорость загрузки используемого кабельного соединения. Теперь мы можем проверить производительность VPN-туннеля в той же сети:

 3] 0,0-10,8 с 5,25 МБайт 4,09 Мбит / с

Повторение измерения дает очень похожие цифры, поэтому справедливо утверждать, что производительность VPN-туннеля на несколько процентов ниже производительности базовой сети. Это на самом деле имеет смысл, так как использование VPN действительно создает некоторые накладные расходы для инкапсуляции, шифрования и аутентификации (подписи) исходные данные. Это будет трудно для дальнейшей оптимизации этой сети.

Аналогично, для скорости загрузки используемого кабельного соединения мы обнаруживаем, что производительность VPN-туннеля на несколько процентов ниже:

Производительность базовой сети показана следующим образом:

 4] 0,0-10,6 с 51,6 МБайт 40,7 Мбит / с

Теперь сравните это с VPN-туннелем:

 4] 0,0-10,7 с 49,5 МБайт 39,0 Мбит / с

Опять же, мы видим снижение производительности на 4,5 процента.

Теперь мы можем использовать параметры фрагмента и mssfix, чтобы посмотреть, сможем ли мы повысить производительность. Там будет немного проб и ошибок, чтобы найти подходящее место для конкретной установки. Неизвестно, какое именно место будет заранее, но метод его определения всегда один и тот же. Теперь добавьте параметры в файлы конфигурации клиента и сервера:

фрагмент X

mssfix

Делая это и изменяя X , мы получаем следующие результаты:



X (байты) Загрузить (Мбит / с) Загрузить (Мбит / с)


1200
37,9
3,94










1300
38,1
4,01










1400
38,4
4,04










1472
38,8
4,06












1500 37,6 3,98


<нет> 39,0
4,09
















Мы можем заключить, что настройки OpenVPN по умолчанию - самое приятное место для этой сети. Мы могли бы повторить это упражнение, изменив параметр tun-mtu , но мы нашли бы тот же результат. Однако рекомендуется сначала настроить производительность с помощью параметра фрагмента , поскольку этот параметр меньше влияет на пересылку пакетов.
Гигабитная сеть

Теперь мы выполним ту же процедуру в неиспользуемой сети Gigabit Ethernet. Производительность iperf базовой сети составляет 950 Мбит / с вверх и вниз.

Когда мы запускаем сервер OpenVPN с помощью конфигурации basic-udp-server.conf и подключаем к нему клиент с помощью файла конфигурации basic-udp-client.conf , мы достигаем следующей производительности iperf :

[ID] Интервал Передача полосы пропускания
[ 5] 0,0-10,0 с 193 МБайт 161 Мбит / с
 4] 0,0-10,0 с 242 МБ 203 Мбит / с

Сейчас наблюдается явное падение производительности. К сожалению, снижение параметра фрагмента нам здесь не поможет. С фрагментом 1200 мы достигаем 149 Мбит / с и 115 Мбит / с соответственно.

В высокоскоростных сетях также имеет смысл поэкспериментировать с шифровальным шифром. Оба сервера, используемые в этом примере, способны выполнять быстрые инструкции AES благодаря расширению AES-NI, которое присутствует в процессорах (Xeon E5 2620 с тактовой частотой 2 ГГц и Xeon E5 2643 с тактовой частотой 3,5 ГГц, соответственно). Давайте добавим следующее:

шифр aes-256-cbc

Теперь мы получаем следующий результат:

[ 5] 0,0-10,0 с 316 МБайт 265 Мбит / с

 4] 0,0-10,0 с 266 МБ 223 Мбит / с

На способном процессоре шифр оказывает большое влияние на производительность. Поскольку OpenVPN является монолитной программой, большое количество ядер не помогает вообще. Тактовая частота процессора является доминирующим фактором. Подключив ноутбук Core i7 с тактовой частотой 3,8 ГГц к серверу Xeon E5-2643 с частотой 3,5 ГГц, мы получаем гораздо более высокую пропускную способность, используя точно такую ​​же конфигурацию:

[
5]
0.0-10.0
сек
707
MBytes
593
Мегабит / сек
[
4]
0.0-10.0
сек
529
MBytes
443
Мегабит / сек


Таким образом, если вы хотите настроить туннель OpenVPN через высокоскоростную сеть, то лучший совет - использовать высокопроизводительные ЦП, которые поддерживают Набор инструкций AES-NI. С такой настройкой можно достичь скорости сети более 500 Мбит / с в обоих направлениях.
